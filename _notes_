ImageFile.jpg -> ImageFile.jpg.rgb
64x64x6bit, 9216 bytes, with 50% grey padding

__________________		__________________
|        |        |		|        |        |
|        |        |		|        |        |
|        |        |		|        |        |
|        |        |		|        |        |
|________|________|		|________|________|
|        |        |		|        |        |
|        |        |		|        |        |
|        |        |		|        |        |
|        |        |		|        |        |
|________|________|		| _______|________|

Average greyscale of		Average hue of
quadrants in 6 bit		quadrants in 6 bit
expressed as base		expressed as base
64 characters			64 characters

0 1 2 3 4 5 6 7
8 9 a b c d e f
g h i j k l m n
o p q r s t u v
w x y z A B C D
E F G H I J L K
M N O P Q R S T
U V W X Y Z - +

Greystamp: The RGB of pixels in each quadrant added together divided by 4096

Huestamp: Each of R, G and B added together separately for each quadrant and divided by 4096.
Then hue calculated for 6 bit
r>(g|r)=MOD((g-b)/(MIN-MAX),6)*10.5
g>(r|b)=(2+((b-r)/(MIN-MAX)))*10.5
r>(r|g)=(4+((r-g)/(MIN-MAX)))*10.5

Magnitude: Image megapixel count expressed as 6 bit.
((pixels/450)^(1/3))-3
0=100x75, 1=200x150, 2=300x225, 4=400x300 ... 10=1200x900 ... 20=2700x2025 ... 30=4600x3450 ... 63=13000x9750

Append statistics to rgb thumnail filename
ImageFile.jpg_wgMw_Qc7k_b.tprt
 <orig file> <grey|hue><mag>

One array per quadrant: float red, float green, float blue

Read 9 bytes from file, use division and modululus to turn 12 6 bit values into 8 bit and return averages the channels to the quadrant array.

Process upper left and upper right quadrants through 32 times 16 chunks of 9 bytes - 8 per quadrant.
Repeat for bottom half.

Quadrant arrays accumulate 256 four pixel averages per channel.

Grey level per quadrant is three channels all added and averaged.  Three channels averaged and hue calculated.

Create thumbnails (ImageFile.jpg.rgb), 

>convert "$f" -resize 400x500\! -set filename:f "%[t]-%[w]x%[h]" "%[filename:f].png"<
From: https://stackoverflow.com/questions/40320119/mogrify-resize-and-append-new-filesize-to-filename

Use bit fields for 6 bit handling?
struct S {
 // 6-bit unsigned field,
 // allowed values are 0...63
 unsigned int b : 6;
};

Bit masking
https://www.geeksforgeeks.org/c/c-bitmasking/

ImageMagick
-set filename:f '%t_magnify.%e' +adjoin '%[filename:f]'

Formula for number of pixels to b64:
( ( pix^0.408163265306) /28.8 ) - 0.83

https://stackoverflow.com/questions/3747086/reading-the-whole-text-file-into-a-char-array-in-c
FILE *fptr;
char *msg;
long length;
size_t read_s = 0;  
fptr = fopen("example_test.xml", "rb");
fseek(fptr, 0L, SEEK_END);
length = ftell(fptr);
rewind(fptr);
msg = (char*)malloc((length+1));
read_s = fread(msg, 1, length, fptr);
*(mip_msg+ read_s) = 0;
if (fptr) fclose(fptr);


Make thumbnails
Change thumbnail names to reflect magnitude, greyscale and hue prints
Create database of thumbnail filenames
Compare single images to database | Search for duplicates in database
Delete thumbnails
Keep database for reference


Tools
Make thumbnails
Rename thumbnails with prints etc ???
Write database of prints with names etc
Look for duplicates in database
Compare databases


Duplicates
Sort database by print - 0-9, a-z, A-Z, -+
Go down list looking for duplicates in greyprint, hueprint
Print filenames, prints, and magnitudes of duplicates

Compare two or three thumbnails side by side

Function quad_cmp (char compare, char target)
global switch for fuzzy search
if compare = target OR (fuzzy AND (compare = target -1 OR compare = target +1))
	then return match

Thumbnail comparison
Compare [192,64] six bit unsigned int
Target [192,64] eight bit signed int
Subtract Compare from Target, so target contains number and amount of distance
divide differences into four sections of frequency
	first 16 values - difference of one, to difference of fifteen - makes up fractional portion of similarity number
	1+ 2^2 2^3 2^4 2^5 ... 2^15 
	last 16 values make up the similarity number to the left of decimal point
	1+ 2^2 2^3 2^4 2^5 ... 2^15
	So a large number of small differences will make the decimal portion large and a small number of large differences will make the left of the decimal point large
	similarity/difference number: 0.12345 = difference of compression artifacts, 56789123.12345 = artifacts plus superimposed text
Histogram.
Or the first and last quarters of a histogram

Sixteen divisions of four.  The first division kept as four values.  The highest frequency from the other 15 divisions taken, for a total of 19 frequency numbers.
First division for the right of the decimal place.  Other fifteen to the left.  Base 10, base 64?
Or eight divisions of eight.

### change so the file extension being searched is surrounded by spaces

### enquote filenames
